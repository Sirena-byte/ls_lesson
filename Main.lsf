MODULE Main;

REQUIRE Reception, Utils;

migrate 'Перенос данных'(){// Определяем процедуру миграции данных
    //Запрашивает у пользователя подтверждение перед выполнением операции. Если пользователь подтверждает, выполнение продолжается.
    ASK 'Вы действительно хотите выполнить перенос данных?' DO {
        // Цикл для создания единиц (Unit) на основе названий из Reception. Группировка происходит по второму слову в имени.
        //GROUP MAX Reception r BY name(r): Здесь мы группируем объекты Reception по имени (name(r)). Для каждой группы Reception выбирается максимальное значение по критерию name
        //(STRING[100] v): Создается переменная v типа строка длиной до 100 символов, которая будет использоваться для хранения значения.
        //NEW u = Unit: Создается новый объект Unit для каждой группы
        //name(u) <- v: Присваивается имя v новому объекту u.
        FOR [GROUP MAX Reception r BY trim(getWord(name(r), '*', 2))](STRING[100] v) NEW  u = 
            Unit DO {
            // Устанавливаем имя для созданной единицы. Присваивает имя новой единице u на основе значения v.
            name(u) <- v;
        }
        // Цикл, который создает новые продукты (Product) на основе названий из объекта Reception. Группировка происходит по первому слову в имени.
        FOR [GROUP MAX Reception r BY getWord(name(r), '*', 1)](STRING[100] v) NEW p = Product
            //GROUP: Используется для группировки объектов по определенному критерию. Например, можно сгруппировать объекты по какому-то свойству или значению.
            //MAX: Это агрегатная функция, которая возвращает максимальное значение из группы. Она может применяться к числовым значениям, строкам и другим типам данных, в зависимости от контекста.
            //GROUP MAX object o BY criteria
            //object — тип объекта, который вы хотите сгруппировать.
            //o — переменная, которая будет использоваться для итерации по сгруппированным объектам.
            //BY criteria — условие для группировки, например, по какому-то свойству объекта.
            DO {
            // Устанавливаем имя для созданного продукта. Присваивает имя новому продукту p на основе значения v
            name(p) <- v;
        }
        // Определяем группу для каждого продукта на основе его названия
        group(Product p) <-(
            CASE 
                WHEN istartsWith(name(p), 'Булочка') THEN Group.unique('БУЛОЧКИ')// Если название начинается с 'Булочка', присваиваем группу 'БУЛОЧКИ'
                WHEN istartsWith(name(p), 'Мясо') THEN Group.unique('ПОЛУФАБРИКАТЫ')// Если 'Мясо', присваиваем 'ПОЛУФАБРИКАТЫ'
                WHEN istartsWith(name(p), 'Из мяса') THEN Group.unique('ПРОДУКТЫ ИЗ МЯСА')// Если 'Из мяса', присваиваем 'ПРОДУКТЫ ИЗ МЯСА'
                WHEN istartsWith(name(p), 'Колбаса') THEN Group.unique('КОЛБАСЫ')// Если 'Колбаса', присваиваем 'КОЛБАСЫ'
                ELSE OVERRIDE (GROUP MAX Group g IF istartsWith(name(p), name(g))),
 Group.unique('ВСЕ')   // Если ни одно условие не выполнено, присваиваем группу 'ВСЕ'            
        ) WHERE p IS Product AND NOT group(p);// Условие, чтобы не перезаписывать существующие группы (Условие для определения, что p является продуктом и не имеет назначенной группы.)
        APPLY ; // Применяем изменения (Применяет все изменения, сделанные в текущем блоке.)
        // Устанавливаем единицу для каждого продукта, если она еще не установлена
        unit(Reception r) <- Unit.unique(upper(trim(getWord(name(r), '*', 2)))) WHERE r IS Reception AND NOT unit(r);
        // Устанавливает продукт для каждого объекта Reception, если он еще не был установлен.
        product(Reception r) <- Product.unique(upper(getWord(name(r), '*', 1))) WHERE r IS Reception AND NOT product(r);
        
        APPLY ;// Применяем изменения
        IF NOT canceled() THEN // Проверяем, было ли действие отменено пользователем.  Системное свойство canceled() будет NULL, если изменения удалось применить в базу данных. При отмене операции применения изменений в базу данных (APPLY) в результате выполнения оператора CANCEL или нарушения какого-либо ограничения, в локальное свойство canceled() записывается TRUE
            MESSAGE 'Операция выполнена';
        ELSE 
            MESSAGE 'Операция не выполнена\nИз-за существующих ограничений\nВозможно, миграция выполняется повторно';
    }ELSE {
        MESSAGE 'Выполнение отменено';
    }
}
EXTEND FORM migrationData PROPERTIES migrate();

DESIGN migrationData{
    commons{
        MOVE PROPERTY (migrate()); // Поместив действие migrate() в блок формы PROPERTIES создали кнопку на форме
    }
}
